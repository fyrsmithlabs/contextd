// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: contextd/v1/contextd.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SafeExecService_Bash_FullMethodName  = "/contextd.v1.SafeExecService/Bash"
	SafeExecService_Read_FullMethodName  = "/contextd.v1.SafeExecService/Read"
	SafeExecService_Write_FullMethodName = "/contextd.v1.SafeExecService/Write"
)

// SafeExecServiceClient is the client API for SafeExecService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SafeExecServiceClient interface {
	Bash(ctx context.Context, in *BashRequest, opts ...grpc.CallOption) (*BashResponse, error)
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error)
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error)
}

type safeExecServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSafeExecServiceClient(cc grpc.ClientConnInterface) SafeExecServiceClient {
	return &safeExecServiceClient{cc}
}

func (c *safeExecServiceClient) Bash(ctx context.Context, in *BashRequest, opts ...grpc.CallOption) (*BashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BashResponse)
	err := c.cc.Invoke(ctx, SafeExecService_Bash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *safeExecServiceClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadResponse)
	err := c.cc.Invoke(ctx, SafeExecService_Read_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *safeExecServiceClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteResponse)
	err := c.cc.Invoke(ctx, SafeExecService_Write_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SafeExecServiceServer is the server API for SafeExecService service.
// All implementations must embed UnimplementedSafeExecServiceServer
// for forward compatibility.
type SafeExecServiceServer interface {
	Bash(context.Context, *BashRequest) (*BashResponse, error)
	Read(context.Context, *ReadRequest) (*ReadResponse, error)
	Write(context.Context, *WriteRequest) (*WriteResponse, error)
	mustEmbedUnimplementedSafeExecServiceServer()
}

// UnimplementedSafeExecServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSafeExecServiceServer struct{}

func (UnimplementedSafeExecServiceServer) Bash(context.Context, *BashRequest) (*BashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bash not implemented")
}
func (UnimplementedSafeExecServiceServer) Read(context.Context, *ReadRequest) (*ReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedSafeExecServiceServer) Write(context.Context, *WriteRequest) (*WriteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Write not implemented")
}
func (UnimplementedSafeExecServiceServer) mustEmbedUnimplementedSafeExecServiceServer() {}
func (UnimplementedSafeExecServiceServer) testEmbeddedByValue()                         {}

// UnsafeSafeExecServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SafeExecServiceServer will
// result in compilation errors.
type UnsafeSafeExecServiceServer interface {
	mustEmbedUnimplementedSafeExecServiceServer()
}

func RegisterSafeExecServiceServer(s grpc.ServiceRegistrar, srv SafeExecServiceServer) {
	// If the following call pancis, it indicates UnimplementedSafeExecServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SafeExecService_ServiceDesc, srv)
}

func _SafeExecService_Bash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SafeExecServiceServer).Bash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SafeExecService_Bash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SafeExecServiceServer).Bash(ctx, req.(*BashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SafeExecService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SafeExecServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SafeExecService_Read_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SafeExecServiceServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SafeExecService_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SafeExecServiceServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SafeExecService_Write_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SafeExecServiceServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SafeExecService_ServiceDesc is the grpc.ServiceDesc for SafeExecService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SafeExecService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contextd.v1.SafeExecService",
	HandlerType: (*SafeExecServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Bash",
			Handler:    _SafeExecService_Bash_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _SafeExecService_Read_Handler,
		},
		{
			MethodName: "Write",
			Handler:    _SafeExecService_Write_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contextd/v1/contextd.proto",
}

const (
	MemoryService_Search_FullMethodName   = "/contextd.v1.MemoryService/Search"
	MemoryService_Store_FullMethodName    = "/contextd.v1.MemoryService/Store"
	MemoryService_Feedback_FullMethodName = "/contextd.v1.MemoryService/Feedback"
	MemoryService_Get_FullMethodName      = "/contextd.v1.MemoryService/Get"
)

// MemoryServiceClient is the client API for MemoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MemoryServiceClient interface {
	Search(ctx context.Context, in *MemorySearchRequest, opts ...grpc.CallOption) (*MemorySearchResponse, error)
	Store(ctx context.Context, in *MemoryStoreRequest, opts ...grpc.CallOption) (*MemoryStoreResponse, error)
	Feedback(ctx context.Context, in *MemoryFeedbackRequest, opts ...grpc.CallOption) (*MemoryFeedbackResponse, error)
	Get(ctx context.Context, in *MemoryGetRequest, opts ...grpc.CallOption) (*MemoryGetResponse, error)
}

type memoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMemoryServiceClient(cc grpc.ClientConnInterface) MemoryServiceClient {
	return &memoryServiceClient{cc}
}

func (c *memoryServiceClient) Search(ctx context.Context, in *MemorySearchRequest, opts ...grpc.CallOption) (*MemorySearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemorySearchResponse)
	err := c.cc.Invoke(ctx, MemoryService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Store(ctx context.Context, in *MemoryStoreRequest, opts ...grpc.CallOption) (*MemoryStoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryStoreResponse)
	err := c.cc.Invoke(ctx, MemoryService_Store_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Feedback(ctx context.Context, in *MemoryFeedbackRequest, opts ...grpc.CallOption) (*MemoryFeedbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryFeedbackResponse)
	err := c.cc.Invoke(ctx, MemoryService_Feedback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Get(ctx context.Context, in *MemoryGetRequest, opts ...grpc.CallOption) (*MemoryGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MemoryGetResponse)
	err := c.cc.Invoke(ctx, MemoryService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MemoryServiceServer is the server API for MemoryService service.
// All implementations must embed UnimplementedMemoryServiceServer
// for forward compatibility.
type MemoryServiceServer interface {
	Search(context.Context, *MemorySearchRequest) (*MemorySearchResponse, error)
	Store(context.Context, *MemoryStoreRequest) (*MemoryStoreResponse, error)
	Feedback(context.Context, *MemoryFeedbackRequest) (*MemoryFeedbackResponse, error)
	Get(context.Context, *MemoryGetRequest) (*MemoryGetResponse, error)
	mustEmbedUnimplementedMemoryServiceServer()
}

// UnimplementedMemoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMemoryServiceServer struct{}

func (UnimplementedMemoryServiceServer) Search(context.Context, *MemorySearchRequest) (*MemorySearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedMemoryServiceServer) Store(context.Context, *MemoryStoreRequest) (*MemoryStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Store not implemented")
}
func (UnimplementedMemoryServiceServer) Feedback(context.Context, *MemoryFeedbackRequest) (*MemoryFeedbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Feedback not implemented")
}
func (UnimplementedMemoryServiceServer) Get(context.Context, *MemoryGetRequest) (*MemoryGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMemoryServiceServer) mustEmbedUnimplementedMemoryServiceServer() {}
func (UnimplementedMemoryServiceServer) testEmbeddedByValue()                       {}

// UnsafeMemoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MemoryServiceServer will
// result in compilation errors.
type UnsafeMemoryServiceServer interface {
	mustEmbedUnimplementedMemoryServiceServer()
}

func RegisterMemoryServiceServer(s grpc.ServiceRegistrar, srv MemoryServiceServer) {
	// If the following call pancis, it indicates UnimplementedMemoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MemoryService_ServiceDesc, srv)
}

func _MemoryService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemorySearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Search(ctx, req.(*MemorySearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Store_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Store(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Store_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Store(ctx, req.(*MemoryStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Feedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Feedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Feedback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Feedback(ctx, req.(*MemoryFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Get(ctx, req.(*MemoryGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MemoryService_ServiceDesc is the grpc.ServiceDesc for MemoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MemoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contextd.v1.MemoryService",
	HandlerType: (*MemoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _MemoryService_Search_Handler,
		},
		{
			MethodName: "Store",
			Handler:    _MemoryService_Store_Handler,
		},
		{
			MethodName: "Feedback",
			Handler:    _MemoryService_Feedback_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MemoryService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contextd/v1/contextd.proto",
}

const (
	CheckpointService_Save_FullMethodName   = "/contextd.v1.CheckpointService/Save"
	CheckpointService_List_FullMethodName   = "/contextd.v1.CheckpointService/List"
	CheckpointService_Resume_FullMethodName = "/contextd.v1.CheckpointService/Resume"
)

// CheckpointServiceClient is the client API for CheckpointService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CheckpointServiceClient interface {
	Save(ctx context.Context, in *CheckpointSaveRequest, opts ...grpc.CallOption) (*CheckpointSaveResponse, error)
	List(ctx context.Context, in *CheckpointListRequest, opts ...grpc.CallOption) (*CheckpointListResponse, error)
	Resume(ctx context.Context, in *CheckpointResumeRequest, opts ...grpc.CallOption) (*CheckpointResumeResponse, error)
}

type checkpointServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCheckpointServiceClient(cc grpc.ClientConnInterface) CheckpointServiceClient {
	return &checkpointServiceClient{cc}
}

func (c *checkpointServiceClient) Save(ctx context.Context, in *CheckpointSaveRequest, opts ...grpc.CallOption) (*CheckpointSaveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckpointSaveResponse)
	err := c.cc.Invoke(ctx, CheckpointService_Save_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *checkpointServiceClient) List(ctx context.Context, in *CheckpointListRequest, opts ...grpc.CallOption) (*CheckpointListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckpointListResponse)
	err := c.cc.Invoke(ctx, CheckpointService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *checkpointServiceClient) Resume(ctx context.Context, in *CheckpointResumeRequest, opts ...grpc.CallOption) (*CheckpointResumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckpointResumeResponse)
	err := c.cc.Invoke(ctx, CheckpointService_Resume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CheckpointServiceServer is the server API for CheckpointService service.
// All implementations must embed UnimplementedCheckpointServiceServer
// for forward compatibility.
type CheckpointServiceServer interface {
	Save(context.Context, *CheckpointSaveRequest) (*CheckpointSaveResponse, error)
	List(context.Context, *CheckpointListRequest) (*CheckpointListResponse, error)
	Resume(context.Context, *CheckpointResumeRequest) (*CheckpointResumeResponse, error)
	mustEmbedUnimplementedCheckpointServiceServer()
}

// UnimplementedCheckpointServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCheckpointServiceServer struct{}

func (UnimplementedCheckpointServiceServer) Save(context.Context, *CheckpointSaveRequest) (*CheckpointSaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedCheckpointServiceServer) List(context.Context, *CheckpointListRequest) (*CheckpointListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedCheckpointServiceServer) Resume(context.Context, *CheckpointResumeRequest) (*CheckpointResumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resume not implemented")
}
func (UnimplementedCheckpointServiceServer) mustEmbedUnimplementedCheckpointServiceServer() {}
func (UnimplementedCheckpointServiceServer) testEmbeddedByValue()                           {}

// UnsafeCheckpointServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CheckpointServiceServer will
// result in compilation errors.
type UnsafeCheckpointServiceServer interface {
	mustEmbedUnimplementedCheckpointServiceServer()
}

func RegisterCheckpointServiceServer(s grpc.ServiceRegistrar, srv CheckpointServiceServer) {
	// If the following call pancis, it indicates UnimplementedCheckpointServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CheckpointService_ServiceDesc, srv)
}

func _CheckpointService_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckpointSaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CheckpointServiceServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CheckpointService_Save_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CheckpointServiceServer).Save(ctx, req.(*CheckpointSaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CheckpointService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckpointListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CheckpointServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CheckpointService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CheckpointServiceServer).List(ctx, req.(*CheckpointListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CheckpointService_Resume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckpointResumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CheckpointServiceServer).Resume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CheckpointService_Resume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CheckpointServiceServer).Resume(ctx, req.(*CheckpointResumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CheckpointService_ServiceDesc is the grpc.ServiceDesc for CheckpointService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CheckpointService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contextd.v1.CheckpointService",
	HandlerType: (*CheckpointServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Save",
			Handler:    _CheckpointService_Save_Handler,
		},
		{
			MethodName: "List",
			Handler:    _CheckpointService_List_Handler,
		},
		{
			MethodName: "Resume",
			Handler:    _CheckpointService_Resume_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contextd/v1/contextd.proto",
}

const (
	PolicyService_Check_FullMethodName = "/contextd.v1.PolicyService/Check"
	PolicyService_List_FullMethodName  = "/contextd.v1.PolicyService/List"
	PolicyService_Get_FullMethodName   = "/contextd.v1.PolicyService/Get"
)

// PolicyServiceClient is the client API for PolicyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PolicyServiceClient interface {
	Check(ctx context.Context, in *PolicyCheckRequest, opts ...grpc.CallOption) (*PolicyCheckResponse, error)
	List(ctx context.Context, in *PolicyListRequest, opts ...grpc.CallOption) (*PolicyListResponse, error)
	Get(ctx context.Context, in *PolicyGetRequest, opts ...grpc.CallOption) (*PolicyGetResponse, error)
}

type policyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPolicyServiceClient(cc grpc.ClientConnInterface) PolicyServiceClient {
	return &policyServiceClient{cc}
}

func (c *policyServiceClient) Check(ctx context.Context, in *PolicyCheckRequest, opts ...grpc.CallOption) (*PolicyCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PolicyCheckResponse)
	err := c.cc.Invoke(ctx, PolicyService_Check_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyServiceClient) List(ctx context.Context, in *PolicyListRequest, opts ...grpc.CallOption) (*PolicyListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PolicyListResponse)
	err := c.cc.Invoke(ctx, PolicyService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyServiceClient) Get(ctx context.Context, in *PolicyGetRequest, opts ...grpc.CallOption) (*PolicyGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PolicyGetResponse)
	err := c.cc.Invoke(ctx, PolicyService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PolicyServiceServer is the server API for PolicyService service.
// All implementations must embed UnimplementedPolicyServiceServer
// for forward compatibility.
type PolicyServiceServer interface {
	Check(context.Context, *PolicyCheckRequest) (*PolicyCheckResponse, error)
	List(context.Context, *PolicyListRequest) (*PolicyListResponse, error)
	Get(context.Context, *PolicyGetRequest) (*PolicyGetResponse, error)
	mustEmbedUnimplementedPolicyServiceServer()
}

// UnimplementedPolicyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPolicyServiceServer struct{}

func (UnimplementedPolicyServiceServer) Check(context.Context, *PolicyCheckRequest) (*PolicyCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (UnimplementedPolicyServiceServer) List(context.Context, *PolicyListRequest) (*PolicyListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPolicyServiceServer) Get(context.Context, *PolicyGetRequest) (*PolicyGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedPolicyServiceServer) mustEmbedUnimplementedPolicyServiceServer() {}
func (UnimplementedPolicyServiceServer) testEmbeddedByValue()                       {}

// UnsafePolicyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PolicyServiceServer will
// result in compilation errors.
type UnsafePolicyServiceServer interface {
	mustEmbedUnimplementedPolicyServiceServer()
}

func RegisterPolicyServiceServer(s grpc.ServiceRegistrar, srv PolicyServiceServer) {
	// If the following call pancis, it indicates UnimplementedPolicyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PolicyService_ServiceDesc, srv)
}

func _PolicyService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PolicyService_Check_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServiceServer).Check(ctx, req.(*PolicyCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PolicyService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServiceServer).List(ctx, req.(*PolicyListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PolicyService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServiceServer).Get(ctx, req.(*PolicyGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PolicyService_ServiceDesc is the grpc.ServiceDesc for PolicyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PolicyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contextd.v1.PolicyService",
	HandlerType: (*PolicyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _PolicyService_Check_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PolicyService_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PolicyService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contextd/v1/contextd.proto",
}

const (
	SkillService_List_FullMethodName   = "/contextd.v1.SkillService/List"
	SkillService_Get_FullMethodName    = "/contextd.v1.SkillService/Get"
	SkillService_Create_FullMethodName = "/contextd.v1.SkillService/Create"
	SkillService_Update_FullMethodName = "/contextd.v1.SkillService/Update"
	SkillService_Delete_FullMethodName = "/contextd.v1.SkillService/Delete"
)

// SkillServiceClient is the client API for SkillService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SkillServiceClient interface {
	List(ctx context.Context, in *SkillListRequest, opts ...grpc.CallOption) (*SkillListResponse, error)
	Get(ctx context.Context, in *SkillGetRequest, opts ...grpc.CallOption) (*SkillGetResponse, error)
	Create(ctx context.Context, in *SkillCreateRequest, opts ...grpc.CallOption) (*SkillCreateResponse, error)
	Update(ctx context.Context, in *SkillUpdateRequest, opts ...grpc.CallOption) (*SkillUpdateResponse, error)
	Delete(ctx context.Context, in *SkillDeleteRequest, opts ...grpc.CallOption) (*SkillDeleteResponse, error)
}

type skillServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSkillServiceClient(cc grpc.ClientConnInterface) SkillServiceClient {
	return &skillServiceClient{cc}
}

func (c *skillServiceClient) List(ctx context.Context, in *SkillListRequest, opts ...grpc.CallOption) (*SkillListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SkillListResponse)
	err := c.cc.Invoke(ctx, SkillService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *skillServiceClient) Get(ctx context.Context, in *SkillGetRequest, opts ...grpc.CallOption) (*SkillGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SkillGetResponse)
	err := c.cc.Invoke(ctx, SkillService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *skillServiceClient) Create(ctx context.Context, in *SkillCreateRequest, opts ...grpc.CallOption) (*SkillCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SkillCreateResponse)
	err := c.cc.Invoke(ctx, SkillService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *skillServiceClient) Update(ctx context.Context, in *SkillUpdateRequest, opts ...grpc.CallOption) (*SkillUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SkillUpdateResponse)
	err := c.cc.Invoke(ctx, SkillService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *skillServiceClient) Delete(ctx context.Context, in *SkillDeleteRequest, opts ...grpc.CallOption) (*SkillDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SkillDeleteResponse)
	err := c.cc.Invoke(ctx, SkillService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SkillServiceServer is the server API for SkillService service.
// All implementations must embed UnimplementedSkillServiceServer
// for forward compatibility.
type SkillServiceServer interface {
	List(context.Context, *SkillListRequest) (*SkillListResponse, error)
	Get(context.Context, *SkillGetRequest) (*SkillGetResponse, error)
	Create(context.Context, *SkillCreateRequest) (*SkillCreateResponse, error)
	Update(context.Context, *SkillUpdateRequest) (*SkillUpdateResponse, error)
	Delete(context.Context, *SkillDeleteRequest) (*SkillDeleteResponse, error)
	mustEmbedUnimplementedSkillServiceServer()
}

// UnimplementedSkillServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSkillServiceServer struct{}

func (UnimplementedSkillServiceServer) List(context.Context, *SkillListRequest) (*SkillListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedSkillServiceServer) Get(context.Context, *SkillGetRequest) (*SkillGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSkillServiceServer) Create(context.Context, *SkillCreateRequest) (*SkillCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedSkillServiceServer) Update(context.Context, *SkillUpdateRequest) (*SkillUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedSkillServiceServer) Delete(context.Context, *SkillDeleteRequest) (*SkillDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSkillServiceServer) mustEmbedUnimplementedSkillServiceServer() {}
func (UnimplementedSkillServiceServer) testEmbeddedByValue()                      {}

// UnsafeSkillServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SkillServiceServer will
// result in compilation errors.
type UnsafeSkillServiceServer interface {
	mustEmbedUnimplementedSkillServiceServer()
}

func RegisterSkillServiceServer(s grpc.ServiceRegistrar, srv SkillServiceServer) {
	// If the following call pancis, it indicates UnimplementedSkillServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SkillService_ServiceDesc, srv)
}

func _SkillService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkillListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SkillServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SkillService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SkillServiceServer).List(ctx, req.(*SkillListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SkillService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkillGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SkillServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SkillService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SkillServiceServer).Get(ctx, req.(*SkillGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SkillService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkillCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SkillServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SkillService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SkillServiceServer).Create(ctx, req.(*SkillCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SkillService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkillUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SkillServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SkillService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SkillServiceServer).Update(ctx, req.(*SkillUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SkillService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkillDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SkillServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SkillService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SkillServiceServer).Delete(ctx, req.(*SkillDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SkillService_ServiceDesc is the grpc.ServiceDesc for SkillService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SkillService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contextd.v1.SkillService",
	HandlerType: (*SkillServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _SkillService_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _SkillService_Get_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _SkillService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _SkillService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _SkillService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contextd/v1/contextd.proto",
}

const (
	AgentService_List_FullMethodName   = "/contextd.v1.AgentService/List"
	AgentService_Get_FullMethodName    = "/contextd.v1.AgentService/Get"
	AgentService_Create_FullMethodName = "/contextd.v1.AgentService/Create"
	AgentService_Update_FullMethodName = "/contextd.v1.AgentService/Update"
	AgentService_Delete_FullMethodName = "/contextd.v1.AgentService/Delete"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgentServiceClient interface {
	List(ctx context.Context, in *AgentListRequest, opts ...grpc.CallOption) (*AgentListResponse, error)
	Get(ctx context.Context, in *AgentGetRequest, opts ...grpc.CallOption) (*AgentGetResponse, error)
	Create(ctx context.Context, in *AgentCreateRequest, opts ...grpc.CallOption) (*AgentCreateResponse, error)
	Update(ctx context.Context, in *AgentUpdateRequest, opts ...grpc.CallOption) (*AgentUpdateResponse, error)
	Delete(ctx context.Context, in *AgentDeleteRequest, opts ...grpc.CallOption) (*AgentDeleteResponse, error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) List(ctx context.Context, in *AgentListRequest, opts ...grpc.CallOption) (*AgentListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentListResponse)
	err := c.cc.Invoke(ctx, AgentService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) Get(ctx context.Context, in *AgentGetRequest, opts ...grpc.CallOption) (*AgentGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentGetResponse)
	err := c.cc.Invoke(ctx, AgentService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) Create(ctx context.Context, in *AgentCreateRequest, opts ...grpc.CallOption) (*AgentCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentCreateResponse)
	err := c.cc.Invoke(ctx, AgentService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) Update(ctx context.Context, in *AgentUpdateRequest, opts ...grpc.CallOption) (*AgentUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentUpdateResponse)
	err := c.cc.Invoke(ctx, AgentService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) Delete(ctx context.Context, in *AgentDeleteRequest, opts ...grpc.CallOption) (*AgentDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentDeleteResponse)
	err := c.cc.Invoke(ctx, AgentService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServiceServer is the server API for AgentService service.
// All implementations must embed UnimplementedAgentServiceServer
// for forward compatibility.
type AgentServiceServer interface {
	List(context.Context, *AgentListRequest) (*AgentListResponse, error)
	Get(context.Context, *AgentGetRequest) (*AgentGetResponse, error)
	Create(context.Context, *AgentCreateRequest) (*AgentCreateResponse, error)
	Update(context.Context, *AgentUpdateRequest) (*AgentUpdateResponse, error)
	Delete(context.Context, *AgentDeleteRequest) (*AgentDeleteResponse, error)
	mustEmbedUnimplementedAgentServiceServer()
}

// UnimplementedAgentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServiceServer struct{}

func (UnimplementedAgentServiceServer) List(context.Context, *AgentListRequest) (*AgentListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAgentServiceServer) Get(context.Context, *AgentGetRequest) (*AgentGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAgentServiceServer) Create(context.Context, *AgentCreateRequest) (*AgentCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAgentServiceServer) Update(context.Context, *AgentUpdateRequest) (*AgentUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAgentServiceServer) Delete(context.Context, *AgentDeleteRequest) (*AgentDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAgentServiceServer) mustEmbedUnimplementedAgentServiceServer() {}
func (UnimplementedAgentServiceServer) testEmbeddedByValue()                      {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	// If the following call pancis, it indicates UnimplementedAgentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).List(ctx, req.(*AgentListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).Get(ctx, req.(*AgentGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).Create(ctx, req.(*AgentCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).Update(ctx, req.(*AgentUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).Delete(ctx, req.(*AgentDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contextd.v1.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _AgentService_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AgentService_Get_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _AgentService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AgentService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AgentService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contextd/v1/contextd.proto",
}

const (
	RemediationService_Search_FullMethodName = "/contextd.v1.RemediationService/Search"
	RemediationService_Record_FullMethodName = "/contextd.v1.RemediationService/Record"
)

// RemediationServiceClient is the client API for RemediationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RemediationServiceClient interface {
	Search(ctx context.Context, in *RemediationSearchRequest, opts ...grpc.CallOption) (*RemediationSearchResponse, error)
	Record(ctx context.Context, in *RemediationRecordRequest, opts ...grpc.CallOption) (*RemediationRecordResponse, error)
}

type remediationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRemediationServiceClient(cc grpc.ClientConnInterface) RemediationServiceClient {
	return &remediationServiceClient{cc}
}

func (c *remediationServiceClient) Search(ctx context.Context, in *RemediationSearchRequest, opts ...grpc.CallOption) (*RemediationSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemediationSearchResponse)
	err := c.cc.Invoke(ctx, RemediationService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *remediationServiceClient) Record(ctx context.Context, in *RemediationRecordRequest, opts ...grpc.CallOption) (*RemediationRecordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemediationRecordResponse)
	err := c.cc.Invoke(ctx, RemediationService_Record_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RemediationServiceServer is the server API for RemediationService service.
// All implementations must embed UnimplementedRemediationServiceServer
// for forward compatibility.
type RemediationServiceServer interface {
	Search(context.Context, *RemediationSearchRequest) (*RemediationSearchResponse, error)
	Record(context.Context, *RemediationRecordRequest) (*RemediationRecordResponse, error)
	mustEmbedUnimplementedRemediationServiceServer()
}

// UnimplementedRemediationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRemediationServiceServer struct{}

func (UnimplementedRemediationServiceServer) Search(context.Context, *RemediationSearchRequest) (*RemediationSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedRemediationServiceServer) Record(context.Context, *RemediationRecordRequest) (*RemediationRecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Record not implemented")
}
func (UnimplementedRemediationServiceServer) mustEmbedUnimplementedRemediationServiceServer() {}
func (UnimplementedRemediationServiceServer) testEmbeddedByValue()                            {}

// UnsafeRemediationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RemediationServiceServer will
// result in compilation errors.
type UnsafeRemediationServiceServer interface {
	mustEmbedUnimplementedRemediationServiceServer()
}

func RegisterRemediationServiceServer(s grpc.ServiceRegistrar, srv RemediationServiceServer) {
	// If the following call pancis, it indicates UnimplementedRemediationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RemediationService_ServiceDesc, srv)
}

func _RemediationService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemediationSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemediationServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemediationService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemediationServiceServer).Search(ctx, req.(*RemediationSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemediationService_Record_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemediationRecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemediationServiceServer).Record(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemediationService_Record_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemediationServiceServer).Record(ctx, req.(*RemediationRecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RemediationService_ServiceDesc is the grpc.ServiceDesc for RemediationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RemediationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contextd.v1.RemediationService",
	HandlerType: (*RemediationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _RemediationService_Search_Handler,
		},
		{
			MethodName: "Record",
			Handler:    _RemediationService_Record_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contextd/v1/contextd.proto",
}

const (
	RefService_GetContent_FullMethodName = "/contextd.v1.RefService/GetContent"
)

// RefServiceClient is the client API for RefService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RefServiceClient interface {
	GetContent(ctx context.Context, in *RefGetContentRequest, opts ...grpc.CallOption) (*RefGetContentResponse, error)
}

type refServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRefServiceClient(cc grpc.ClientConnInterface) RefServiceClient {
	return &refServiceClient{cc}
}

func (c *refServiceClient) GetContent(ctx context.Context, in *RefGetContentRequest, opts ...grpc.CallOption) (*RefGetContentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefGetContentResponse)
	err := c.cc.Invoke(ctx, RefService_GetContent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RefServiceServer is the server API for RefService service.
// All implementations must embed UnimplementedRefServiceServer
// for forward compatibility.
type RefServiceServer interface {
	GetContent(context.Context, *RefGetContentRequest) (*RefGetContentResponse, error)
	mustEmbedUnimplementedRefServiceServer()
}

// UnimplementedRefServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRefServiceServer struct{}

func (UnimplementedRefServiceServer) GetContent(context.Context, *RefGetContentRequest) (*RefGetContentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContent not implemented")
}
func (UnimplementedRefServiceServer) mustEmbedUnimplementedRefServiceServer() {}
func (UnimplementedRefServiceServer) testEmbeddedByValue()                    {}

// UnsafeRefServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RefServiceServer will
// result in compilation errors.
type UnsafeRefServiceServer interface {
	mustEmbedUnimplementedRefServiceServer()
}

func RegisterRefServiceServer(s grpc.ServiceRegistrar, srv RefServiceServer) {
	// If the following call pancis, it indicates UnimplementedRefServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RefService_ServiceDesc, srv)
}

func _RefService_GetContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefGetContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RefServiceServer).GetContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RefService_GetContent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RefServiceServer).GetContent(ctx, req.(*RefGetContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RefService_ServiceDesc is the grpc.ServiceDesc for RefService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RefService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contextd.v1.RefService",
	HandlerType: (*RefServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetContent",
			Handler:    _RefService_GetContent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contextd/v1/contextd.proto",
}

const (
	SessionService_Start_FullMethodName = "/contextd.v1.SessionService/Start"
	SessionService_End_FullMethodName   = "/contextd.v1.SessionService/End"
)

// SessionServiceClient is the client API for SessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionServiceClient interface {
	Start(ctx context.Context, in *SessionStartRequest, opts ...grpc.CallOption) (*SessionStartResponse, error)
	End(ctx context.Context, in *SessionEndRequest, opts ...grpc.CallOption) (*SessionEndResponse, error)
}

type sessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionServiceClient(cc grpc.ClientConnInterface) SessionServiceClient {
	return &sessionServiceClient{cc}
}

func (c *sessionServiceClient) Start(ctx context.Context, in *SessionStartRequest, opts ...grpc.CallOption) (*SessionStartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionStartResponse)
	err := c.cc.Invoke(ctx, SessionService_Start_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) End(ctx context.Context, in *SessionEndRequest, opts ...grpc.CallOption) (*SessionEndResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionEndResponse)
	err := c.cc.Invoke(ctx, SessionService_End_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionServiceServer is the server API for SessionService service.
// All implementations must embed UnimplementedSessionServiceServer
// for forward compatibility.
type SessionServiceServer interface {
	Start(context.Context, *SessionStartRequest) (*SessionStartResponse, error)
	End(context.Context, *SessionEndRequest) (*SessionEndResponse, error)
	mustEmbedUnimplementedSessionServiceServer()
}

// UnimplementedSessionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionServiceServer struct{}

func (UnimplementedSessionServiceServer) Start(context.Context, *SessionStartRequest) (*SessionStartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedSessionServiceServer) End(context.Context, *SessionEndRequest) (*SessionEndResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method End not implemented")
}
func (UnimplementedSessionServiceServer) mustEmbedUnimplementedSessionServiceServer() {}
func (UnimplementedSessionServiceServer) testEmbeddedByValue()                        {}

// UnsafeSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionServiceServer will
// result in compilation errors.
type UnsafeSessionServiceServer interface {
	mustEmbedUnimplementedSessionServiceServer()
}

func RegisterSessionServiceServer(s grpc.ServiceRegistrar, srv SessionServiceServer) {
	// If the following call pancis, it indicates UnimplementedSessionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionService_ServiceDesc, srv)
}

func _SessionService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionStartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_Start_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).Start(ctx, req.(*SessionStartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_End_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).End(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_End_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).End(ctx, req.(*SessionEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionService_ServiceDesc is the grpc.ServiceDesc for SessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "contextd.v1.SessionService",
	HandlerType: (*SessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _SessionService_Start_Handler,
		},
		{
			MethodName: "End",
			Handler:    _SessionService_End_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contextd/v1/contextd.proto",
}
